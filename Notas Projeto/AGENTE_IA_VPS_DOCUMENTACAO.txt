
# üìã DOCUMENTA√á√ÉO COMPLETA - AGENTE IA PARA VPS

## üéØ VIS√ÉO GERAL DO PROJETO

Este documento fornece todas as informa√ß√µes necess√°rias para desenvolver um **Agente IA em Python** que rodar√° em uma **VPS externa** e se integrar√° com o sistema imobili√°rio **Toca Im√≥veis** atrav√©s do **Supabase**.

### üîó CONTEXTO DO SISTEMA
- **Frontend**: React + TypeScript (j√° implementado)
- **Backend**: Supabase (PostgreSQL + Edge Functions)
- **Agente IA**: Python na VPS (a ser desenvolvido)
- **Integra√ß√£o**: WhatsApp API + Supabase Database

---

## üóÑÔ∏è CONEX√ÉO COM SUPABASE

### Dados de Conex√£o
```python
# Configura√ß√µes do Supabase
SUPABASE_URL = "https://rqyyoofuwrwwfcuxfjwu.supabase.co"
SUPABASE_ANON_KEY = "eyJhbGciOiJIUzI1NiIsInR5cCI6IkpXVCJ9.eyJpc3MiOiJzdXBhYmFzZSIsInJlZiI6InJxeXlvb2Z1d3J3d2ZjdXhmand1Iiwicm9sZSI6ImFub24iLCJpYXQiOjE3NTAwODk2MjUsImV4cCI6MjA2NTY2NTYyNX0.lBOrYvRIGEhLLMgcaaooS9-w2M8VAZW_4rQYFxc6abE"
PROJECT_ID = "rqyyoofuwrwwfcuxfjwu"
```

### Exemplo de Conex√£o Python
```python
from supabase import create_client, Client
import os

# Configurar cliente Supabase
supabase_url = "https://rqyyoofuwrwwfcuxfjwu.supabase.co"
supabase_key = "eyJhbGciOiJIUzI1NiIsInR5cCI6IkpXVCJ9.eyJpc3MiOiJzdXBhYmFzZSIsInJlZiI6InJxeXlvb2Z1d3J3d2ZjdXhmand1Iiwicm9sZSI6ImFub24iLCJpYXQiOjE3NTAwODk2MjUsImV4cCI6MjA2NTY2NTYyNX0.lBOrYvRIGEhLLMgcaaooS9-w2M8VAZW_4rQYFxc6abE"

supabase: Client = create_client(supabase_url, supabase_key)

# Teste de conex√£o
def test_connection():
    try:
        result = supabase.table('ai_negotiations').select('*').limit(1).execute()
        print("‚úÖ Conex√£o com Supabase estabelecida com sucesso!")
        return True
    except Exception as e:
        print(f"‚ùå Erro na conex√£o: {e}")
        return False
```

---

## üóÇÔ∏è ESTRUTURA DAS TABELAS DA IA

### 1. TABELA: `ai_negotiations` (NEGOCIA√á√ïES PRINCIPAIS)

**Descri√ß√£o**: Tabela principal que armazena cada negocia√ß√£o iniciada pela IA via WhatsApp.

**Estrutura**:
```sql
CREATE TABLE ai_negotiations (
  id UUID PRIMARY KEY DEFAULT gen_random_uuid(),
  client_name TEXT NOT NULL,              -- Nome do cliente
  client_phone TEXT NOT NULL,             -- Telefone do cliente (5514999999999)
  client_email TEXT,                      -- Email do cliente (opcional)
  property_id UUID REFERENCES properties(id), -- ID do im√≥vel de interesse
  rental_modality rental_modality NOT NULL DEFAULT 'residencial', -- Tipo de loca√ß√£o
  status ai_negotiation_status NOT NULL DEFAULT 'iniciada', -- Status da negocia√ß√£o
  broker_id UUID REFERENCES system_users(id), -- ID do corretor respons√°vel
  started_at TIMESTAMP WITH TIME ZONE NOT NULL DEFAULT now(), -- Quando iniciou
  completed_at TIMESTAMP WITH TIME ZONE, -- Quando finalizou (se finalizou)
  created_at TIMESTAMP WITH TIME ZONE NOT NULL DEFAULT now(),
  updated_at TIMESTAMP WITH TIME ZONE NOT NULL DEFAULT now(),
  metadata JSONB DEFAULT '{}'::jsonb      -- Dados extras em JSON
);
```

**Enums Importantes**:
```sql
-- Status poss√≠veis da negocia√ß√£o
CREATE TYPE ai_negotiation_status AS ENUM (
  'iniciada',               -- Negocia√ß√£o rec√©m iniciada
  'coletando_documentos',   -- IA est√° coletando documentos
  'documentos_pendentes',   -- Aguardando documentos do cliente
  'documentos_validados',   -- Documentos foram validados
  'aguardando_corretor',    -- Corretor precisa agir
  'finalizada',             -- Negocia√ß√£o conclu√≠da
  'cancelada'               -- Negocia√ß√£o cancelada
);

-- Modalidades de loca√ß√£o
CREATE TYPE rental_modality AS ENUM (
  'residencial',  -- Residencial
  'comercial',    -- Comercial
  'temporada',    -- Temporada
  'estudantil'    -- Estudantil
);
```

**Exemplo de Uso Python**:
```python
# Criar nova negocia√ß√£o
def criar_negociacao(client_name, client_phone, property_id=None):
    data = {
        "client_name": client_name,
        "client_phone": client_phone,
        "rental_modality": "residencial",
        "status": "iniciada"
    }
    
    if property_id:
        data["property_id"] = property_id
    
    result = supabase.table('ai_negotiations').insert(data).execute()
    return result.data[0] if result.data else None

# Atualizar status da negocia√ß√£o
def atualizar_status_negociacao(negotiation_id, novo_status):
    result = supabase.table('ai_negotiations').update({
        "status": novo_status,
        "updated_at": "now()"
    }).eq('id', negotiation_id).execute()
    return result.data
```

---

### 2. TABELA: `ai_conversations` (CONVERSAS)

**Descri√ß√£o**: Armazena todas as mensagens trocadas entre IA, cliente e corretor.

**Estrutura**:
```sql
CREATE TABLE ai_conversations (
  id UUID PRIMARY KEY DEFAULT gen_random_uuid(),
  negotiation_id UUID NOT NULL REFERENCES ai_negotiations(id) ON DELETE CASCADE,
  conversation_type conversation_type NOT NULL, -- Tipo de conversa
  sender TEXT NOT NULL,                   -- Quem enviou: 'ia', 'cliente', 'corretor'
  message TEXT NOT NULL,                  -- Conte√∫do da mensagem
  timestamp TIMESTAMP WITH TIME ZONE NOT NULL DEFAULT now(),
  metadata JSONB DEFAULT '{}'::jsonb      -- Dados extras
);
```

**Enum do Tipo de Conversa**:
```sql
CREATE TYPE conversation_type AS ENUM (
  'ia_cliente',   -- Conversa entre IA e Cliente
  'ia_corretor'   -- Conversa entre IA e Corretor
);
```

**Exemplo de Uso Python**:
```python
# Salvar mensagem na conversa
def salvar_mensagem(negotiation_id, sender, message, conversation_type="ia_cliente"):
    data = {
        "negotiation_id": negotiation_id,
        "conversation_type": conversation_type,
        "sender": sender,  # 'ia', 'cliente', 'corretor'
        "message": message
    }
    
    result = supabase.table('ai_conversations').insert(data).execute()
    return result.data[0] if result.data else None

# Buscar hist√≥rico de conversa
def buscar_historico_conversa(negotiation_id, conversation_type="ia_cliente"):
    result = supabase.table('ai_conversations').select('*').eq(
        'negotiation_id', negotiation_id
    ).eq('conversation_type', conversation_type).order('timestamp').execute()
    return result.data
```

---

### 3. TABELA: `ai_document_types` (TIPOS DE DOCUMENTOS)

**Descri√ß√£o**: Define os tipos de documentos que podem ser solicitados pelo sistema.

**Estrutura**:
```sql
CREATE TABLE ai_document_types (
  id UUID PRIMARY KEY DEFAULT gen_random_uuid(),
  name TEXT NOT NULL UNIQUE,              -- Nome do documento
  description TEXT,                       -- Descri√ß√£o
  required BOOLEAN NOT NULL DEFAULT true, -- Se √© obrigat√≥rio
  validation_rules JSONB DEFAULT '{}'::jsonb, -- Regras de valida√ß√£o
  is_active BOOLEAN NOT NULL DEFAULT true,
  created_at TIMESTAMP WITH TIME ZONE NOT NULL DEFAULT now()
);
```

**Tipos Padr√£o J√° Cadastrados**:
```python
TIPOS_DOCUMENTOS_PADRAO = [
    {
        "name": "RG",
        "description": "Documento de identidade",
        "required": True
    },
    {
        "name": "CPF", 
        "description": "Cadastro de Pessoa F√≠sica",
        "required": True
    },
    {
        "name": "Comprovante de Renda",
        "description": "√öltimos 3 holerites ou declara√ß√£o de renda",
        "required": True
    },
    {
        "name": "Comprovante de Resid√™ncia",
        "description": "Conta de luz, √°gua ou telefone",
        "required": True
    },
    {
        "name": "Certid√£o de Nascimento/Casamento",
        "description": "Estado civil",
        "required": False
    },
    {
        "name": "Refer√™ncias Comerciais",
        "description": "Contatos de refer√™ncia",
        "required": False
    }
]
```

**Exemplo de Uso Python**:
```python
# Buscar tipos de documentos obrigat√≥rios
def buscar_documentos_obrigatorios():
    result = supabase.table('ai_document_types').select('*').eq(
        'required', True
    ).eq('is_active', True).execute()
    return result.data
```

---

### 4. TABELA: `ai_documents` (DOCUMENTOS ENVIADOS)

**Descri√ß√£o**: Armazena os documentos enviados pelos clientes durante a negocia√ß√£o.

**Estrutura**:
```sql
CREATE TABLE ai_documents (
  id UUID PRIMARY KEY DEFAULT gen_random_uuid(),
  negotiation_id UUID NOT NULL REFERENCES ai_negotiations(id) ON DELETE CASCADE,
  document_type_id UUID NOT NULL REFERENCES ai_document_types(id),
  file_name TEXT NOT NULL,               -- Nome do arquivo
  file_path TEXT NOT NULL,               -- Caminho no storage
  file_size INTEGER,                     -- Tamanho do arquivo
  mime_type TEXT,                        -- Tipo MIME
  status document_status NOT NULL DEFAULT 'pendente', -- Status do documento
  validation_result JSONB DEFAULT '{}'::jsonb, -- Resultado da valida√ß√£o
  uploaded_at TIMESTAMP WITH TIME ZONE NOT NULL DEFAULT now(),
  validated_at TIMESTAMP WITH TIME ZONE,
  created_at TIMESTAMP WITH TIME ZONE NOT NULL DEFAULT now(),
  updated_at TIMESTAMP WITH TIME ZONE NOT NULL DEFAULT now()
);
```

**Enum de Status dos Documentos**:
```sql
CREATE TYPE document_status AS ENUM (
  'pendente',   -- Aguardando recebimento
  'recebido',   -- Documento recebido
  'validando',  -- Em processo de valida√ß√£o
  'validado',   -- Validado com sucesso
  'erro',       -- Erro no processamento
  'rejeitado'   -- Rejeitado
);
```

**Exemplo de Uso Python**:
```python
# Salvar documento recebido
def salvar_documento(negotiation_id, document_type_id, file_name, file_path, file_size, mime_type):
    data = {
        "negotiation_id": negotiation_id,
        "document_type_id": document_type_id,
        "file_name": file_name,
        "file_path": file_path,
        "file_size": file_size,
        "mime_type": mime_type,
        "status": "recebido"
    }
    
    result = supabase.table('ai_documents').insert(data).execute()
    return result.data[0] if result.data else None

# Atualizar status do documento
def atualizar_status_documento(document_id, status, validation_result=None):
    data = {"status": status}
    if validation_result:
        data["validation_result"] = validation_result
    if status == "validado":
        data["validated_at"] = "now()"
    
    result = supabase.table('ai_documents').update(data).eq('id', document_id).execute()
    return result.data
```

---

## üíæ STORAGE - ARMAZENAMENTO DE DOCUMENTOS

### Bucket de Documentos
- **Nome do Bucket**: `ai-negotiations`
- **P√∫blico**: N√£o (privado)
- **Finalidade**: Armazenar documentos enviados pelos clientes

### Exemplo de Upload Python:
```python
def upload_documento(file_path, negotiation_id, document_name):
    """
    Faz upload de documento para o Supabase Storage
    """
    try:
        # Gerar nome √∫nico para o arquivo
        import uuid
        from datetime import datetime
        
        timestamp = datetime.now().strftime("%Y%m%d_%H%M%S")
        unique_filename = f"{negotiation_id}/{timestamp}_{document_name}"
        
        # Upload para o bucket
        with open(file_path, 'rb') as file:
            result = supabase.storage.from_('ai-negotiations').upload(
                path=unique_filename,
                file=file,
                file_options={"content-type": "application/pdf"}  # Ajustar conforme tipo
            )
        
        if result.error:
            print(f"‚ùå Erro no upload: {result.error}")
            return None
        
        # Obter URL p√∫blica (se necess√°rio)
        public_url = supabase.storage.from_('ai-negotiations').get_public_url(unique_filename)
        
        return {
            "file_path": unique_filename,
            "public_url": public_url
        }
        
    except Exception as e:
        print(f"‚ùå Erro no upload: {e}")
        return None
```

---

## üè† TABELA DE PROPRIEDADES (REFER√äNCIA)

### Estrutura da Tabela `properties`:
```sql
CREATE TABLE properties (
  id UUID PRIMARY KEY DEFAULT gen_random_uuid(),
  title TEXT NOT NULL,                    -- T√≠tulo do im√≥vel
  description TEXT,                       -- Descri√ß√£o
  property_type property_type NOT NULL,   -- Tipo: 'casa', 'apartamento', etc.
  price NUMERIC NOT NULL,                 -- Pre√ßo
  address TEXT NOT NULL,                  -- Endere√ßo
  neighborhood TEXT NOT NULL,             -- Bairro
  city TEXT NOT NULL DEFAULT 'Mar√≠lia',   -- Cidade
  state TEXT NOT NULL DEFAULT 'SP',       -- Estado
  zip_code TEXT,                          -- CEP
  bedrooms INTEGER NOT NULL DEFAULT 0,    -- Quartos
  bathrooms INTEGER NOT NULL DEFAULT 0,   -- Banheiros
  area_sqm INTEGER NOT NULL,              -- √Årea em m¬≤
  parking_spaces INTEGER NOT NULL DEFAULT 0, -- Vagas de garagem
  status property_status NOT NULL DEFAULT 'disponivel', -- Status
  is_active BOOLEAN NOT NULL DEFAULT true,
  is_featured BOOLEAN NOT NULL DEFAULT false,
  amenities JSONB DEFAULT '[]'::jsonb,    -- Comodidades
  latitude NUMERIC,                       -- Latitude
  longitude NUMERIC,                      -- Longitude
  created_at TIMESTAMP WITH TIME ZONE NOT NULL DEFAULT now(),
  updated_at TIMESTAMP WITH TIME ZONE NOT NULL DEFAULT now()
);
```

**Exemplo de Busca de Im√≥veis**:
```python
# Buscar im√≥veis dispon√≠veis
def buscar_imoveis_disponiveis(limite=10):
    result = supabase.table('properties').select('*').eq(
        'status', 'disponivel'
    ).eq('is_active', True).limit(limite).execute()
    return result.data

# Buscar im√≥vel espec√≠fico
def buscar_imovel_por_id(property_id):
    result = supabase.table('properties').select('*').eq('id', property_id).execute()
    return result.data[0] if result.data else None
```

---

## üë• TABELA DE USU√ÅRIOS DO SISTEMA

### Estrutura da Tabela `system_users`:
```sql
CREATE TABLE system_users (
  id UUID PRIMARY KEY DEFAULT gen_random_uuid(),
  username TEXT NOT NULL,                 -- Nome de usu√°rio
  email TEXT NOT NULL,                    -- Email
  full_name TEXT,                         -- Nome completo
  role TEXT NOT NULL DEFAULT 'editor',    -- Papel: 'admin', 'editor'
  sector_id UUID REFERENCES company_sectors(id), -- Setor da empresa
  is_active BOOLEAN NOT NULL DEFAULT true,
  created_at TIMESTAMP WITH TIME ZONE NOT NULL DEFAULT now(),
  updated_at TIMESTAMP WITH TIME ZONE NOT NULL DEFAULT now()
);
```

**Exemplo de Busca de Corretores**:
```python
# Buscar corretores ativos
def buscar_corretores():
    result = supabase.table('system_users').select('*').eq('is_active', True).execute()
    return result.data

# Atribuir corretor a negocia√ß√£o
def atribuir_corretor(negotiation_id, broker_id):
    result = supabase.table('ai_negotiations').update({
        "broker_id": broker_id,
        "status": "aguardando_corretor"
    }).eq('id', negotiation_id).execute()
    return result.data
```

---

## üîÑ FLUXO DE TRABALHO DA IA

### 1. RECEBIMENTO DE MENSAGEM WHATSAPP
```python
def processar_mensagem_whatsapp(phone_number, message_text, sender_name):
    """
    Processa mensagem recebida via WhatsApp
    """
    try:
        # 1. Verificar se j√° existe negocia√ß√£o ativa para este n√∫mero
        negotiation = buscar_negociacao_ativa(phone_number)
        
        if not negotiation:
            # 2. Criar nova negocia√ß√£o
            negotiation = criar_negociacao(
                client_name=sender_name,
                client_phone=phone_number
            )
            
            # 3. Salvar mensagem inicial
            salvar_mensagem(
                negotiation_id=negotiation['id'],
                sender='cliente',
                message=message_text
            )
            
            # 4. Processar inten√ß√£o inicial
            response = processar_intencao_inicial(message_text)
            
        else:
            # 5. Continuar conversa existente
            salvar_mensagem(
                negotiation_id=negotiation['id'],
                sender='cliente',
                message=message_text
            )
            
            response = processar_conversa_existente(negotiation, message_text)
        
        # 6. Salvar resposta da IA
        salvar_mensagem(
            negotiation_id=negotiation['id'],
            sender='ia',
            message=response
        )
        
        # 7. Enviar resposta via WhatsApp
        enviar_mensagem_whatsapp(phone_number, response)
        
        return True
        
    except Exception as e:
        print(f"‚ùå Erro ao processar mensagem: {e}")
        return False
```

### 2. CLASSIFICA√á√ÉO DE INTEN√á√ïES
```python
def processar_intencao_inicial(message_text):
    """
    Classifica a inten√ß√£o inicial do cliente
    """
    intencoes = {
        'buscar_imovel': ['quero alugar', 'procuro casa', 'apartamento', 'im√≥vel'],
        'informacoes': ['informa√ß√£o', 'pre√ßo', 'valor', 'quanto custa'],
        'visita': ['visita', 'ver', 'conhecer', 'agendar'],
        'documentos': ['documento', 'papel', 'contrato']
    }
    
    message_lower = message_text.lower()
    
    for intencao, palavras_chave in intencoes.items():
        if any(palavra in message_lower for palavra in palavras_chave):
            return gerar_resposta_por_intencao(intencao)
    
    # Resposta gen√©rica
    return """
    Ol√°! üëã 
    
    Sou a assistente virtual da Toca Im√≥veis! 
    
    Posso te ajudar com:
    üè† Buscar im√≥veis para aluguel
    üìã Informa√ß√µes sobre documenta√ß√£o
    üìÖ Agendar visitas
    üí∞ Consultar pre√ßos e condi√ß√µes
    
    Como posso te ajudar hoje?
    """
```

### 3. COLETA DE DOCUMENTOS
```python
def iniciar_coleta_documentos(negotiation_id):
    """
    Inicia processo de coleta de documentos
    """
    # Atualizar status da negocia√ß√£o
    atualizar_status_negociacao(negotiation_id, 'coletando_documentos')
    
    # Buscar documentos obrigat√≥rios
    documentos_obrigatorios = buscar_documentos_obrigatorios()
    
    # Gerar lista de documentos necess√°rios
    lista_documentos = []
    for doc in documentos_obrigatorios:
        lista_documentos.append(f"üìÑ {doc['name']} - {doc['description']}")
    
    response = f"""
    üìã **DOCUMENTOS NECESS√ÅRIOS**
    
    Para prosseguir com a loca√ß√£o, preciso dos seguintes documentos:
    
    {chr(10).join(lista_documentos)}
    
    Voc√™ pode enviar os documentos por aqui mesmo! 
    
    Pode ser:
    üì∑ Foto do documento
    üìÑ PDF digitalizado
    üñºÔ∏è Imagem clara e leg√≠vel
    
    Vou te ajudar com cada documento. Vamos come√ßar?
    """
    
    return response
```

### 4. VALIDA√á√ÉO DE DOCUMENTOS
```python
def processar_documento_recebido(negotiation_id, file_path, file_name):
    """
    Processa documento recebido do cliente
    """
    try:
        # 1. Identificar tipo de documento (usando IA/OCR)
        document_type = identificar_tipo_documento(file_path)
        
        if not document_type:
            return "‚ùå N√£o consegui identificar o tipo de documento. Pode me dizer qual documento √© este?"
        
        # 2. Fazer upload para o storage
        upload_result = upload_documento(file_path, negotiation_id, file_name)
        
        if not upload_result:
            return "‚ùå Erro ao salvar documento. Tente enviar novamente."
        
        # 3. Salvar no banco de dados
        document_type_id = buscar_document_type_id(document_type)
        
        doc_record = salvar_documento(
            negotiation_id=negotiation_id,
            document_type_id=document_type_id,
            file_name=file_name,
            file_path=upload_result['file_path'],
            file_size=os.path.getsize(file_path),
            mime_type=get_mime_type(file_path)
        )
        
        # 4. Validar documento (usando IA)
        validation_result = validar_documento(file_path, document_type)
        
        if validation_result['valid']:
            atualizar_status_documento(doc_record['id'], 'validado', validation_result)
            response = f"‚úÖ {document_type} recebido e validado com sucesso!"
        else:
            atualizar_status_documento(doc_record['id'], 'rejeitado', validation_result)
            response = f"‚ùå Problema com {document_type}: {validation_result['error']}"
        
        # 5. Verificar se todos os documentos foram enviados
        verificar_documentos_completos(negotiation_id)
        
        return response
        
    except Exception as e:
        print(f"‚ùå Erro ao processar documento: {e}")
        return "‚ùå Erro ao processar documento. Tente novamente."
```

---

## üì± INTEGRA√á√ÉO COM WHATSAPP

### Webhook para Receber Mensagens
```python
from flask import Flask, request, jsonify

app = Flask(__name__)

@app.route('/webhook/whatsapp', methods=['POST'])
def webhook_whatsapp():
    """
    Webhook para receber mensagens do WhatsApp
    """
    try:
        data = request.json
        
        # Estrutura t√≠pica do webhook WhatsApp
        if 'messages' in data:
            for message in data['messages']:
                phone = message.get('key', {}).get('remoteJid', '').replace('@s.whatsapp.net', '')
                text = message.get('message', {}).get('conversation', '')
                sender_name = message.get('pushName', 'Cliente')
                
                if phone and text:
                    # Processar mensagem
                    processar_mensagem_whatsapp(phone, text, sender_name)
        
        return jsonify({"status": "success"}), 200
        
    except Exception as e:
        print(f"‚ùå Erro no webhook: {e}")
        return jsonify({"error": str(e)}), 500

if __name__ == '__main__':
    app.run(host='0.0.0.0', port=8080)
```

### Enviar Mensagens via WhatsApp API
```python
import requests

def enviar_mensagem_whatsapp(phone_number, message):
    """
    Envia mensagem via WhatsApp API
    """
    try:
        # Configura√ß√µes da API (ajustar conforme seu provedor)
        api_url = "https://api.whatsapp.com/send"  # URL da sua API
        api_token = "SEU_TOKEN_AQUI"  # Token da API
        
        headers = {
            'Authorization': f'Bearer {api_token}',
            'Content-Type': 'application/json'
        }
        
        data = {
            'phone': phone_number,
            'message': message
        }
        
        response = requests.post(api_url, headers=headers, json=data)
        
        if response.status_code == 200:
            print(f"‚úÖ Mensagem enviada para {phone_number}")
            return True
        else:
            print(f"‚ùå Erro ao enviar mensagem: {response.text}")
            return False
            
    except Exception as e:
        print(f"‚ùå Erro ao enviar mensagem: {e}")
        return False
```

---

## üéØ TELA "IA - NEGOCIA√á√ïES" (CONTEXTO FRONTEND)

### O que a Tela Mostra
A tela **"IA - Negocia√ß√µes"** (`/hub/ia-negociacoes`) exibe:

1. **Cards de Estat√≠sticas**:
   - Total de negocia√ß√µes
   - Negocia√ß√µes em andamento
   - Documentos pendentes
   - Negocia√ß√µes finalizadas

2. **Lista de Negocia√ß√µes**:
   - Nome do cliente e telefone
   - Status atual da negocia√ß√£o
   - Im√≥vel de interesse (se houver)
   - Data de in√≠cio
   - Corretor respons√°vel

3. **Modal de Detalhes**:
   - **Aba Conversas**: Hist√≥rico de mensagens IA ‚Üî Cliente e IA ‚Üî Corretor
   - **Aba Documentos**: Status de cada documento solicitado
   - **Aba Timeline**: Linha do tempo da negocia√ß√£o

### Dados Esperados pela Tela
```python
# Exemplo de dados que a tela consome
def obter_dados_para_dashboard():
    """
    Retorna dados formatados para o dashboard
    """
    # Buscar negocia√ß√µes com informa√ß√µes relacionadas
    negotiations = supabase.table('ai_negotiations').select("""
        *,
        property:properties(title, address),
        broker:system_users(full_name, username)
    """).order('created_at', desc=True).execute()
    
    # Estat√≠sticas
    stats = {
        'total': len(negotiations.data),
        'active': len([n for n in negotiations.data if n['status'] not in ['finalizada', 'cancelada']]),
        'completed': len([n for n in negotiations.data if n['status'] == 'finalizada']),
        'pending_docs': len([n for n in negotiations.data if n['status'] == 'documentos_pendentes'])
    }
    
    return {
        'negotiations': negotiations.data,
        'stats': stats
    }
```

---

## üöÄ EXEMPLO DE IMPLEMENTA√á√ÉO COMPLETA

### Estrutura do Projeto Python
```
ai_agent_vps/
‚îú‚îÄ‚îÄ main.py                 # Aplica√ß√£o principal
‚îú‚îÄ‚îÄ models/
‚îÇ   ‚îú‚îÄ‚îÄ supabase_client.py  # Cliente Supabase
‚îÇ   ‚îú‚îÄ‚îÄ negotiations.py     # Modelo de negocia√ß√µes
‚îÇ   ‚îú‚îÄ‚îÄ documents.py        # Modelo de documentos
‚îÇ   ‚îî‚îÄ‚îÄ conversations.py    # Modelo de conversas
‚îú‚îÄ‚îÄ services/
‚îÇ   ‚îú‚îÄ‚îÄ whatsapp_service.py # Servi√ßo WhatsApp
‚îÇ   ‚îú‚îÄ‚îÄ ai_service.py       # Servi√ßo de IA
‚îÇ   ‚îî‚îÄ‚îÄ document_service.py # Processamento de documentos
‚îú‚îÄ‚îÄ utils/
‚îÇ   ‚îú‚îÄ‚îÄ validators.py       # Validadores
‚îÇ   ‚îî‚îÄ‚îÄ helpers.py          # Fun√ß√µes auxiliares
‚îî‚îÄ‚îÄ requirements.txt        # Depend√™ncias
```

### requirements.txt
```
supabase==2.3.4
flask==3.0.0
requests==2.31.0
python-dotenv==1.0.0
openai==1.12.0
python-magic==0.4.27
pillow==10.2.0
pytesseract==0.3.10
```

### Exemplo de Classe Principal
```python
# main.py
from flask import Flask
from models.supabase_client import SupabaseClient
from services.whatsapp_service import WhatsAppService
from services.ai_service import AIService

class AgentIA:
    def __init__(self):
        self.supabase = SupabaseClient()
        self.whatsapp = WhatsAppService()
        self.ai = AIService()
        
    def processar_mensagem(self, phone, message, sender_name):
        """M√©todo principal para processar mensagens"""
        # Implementar l√≥gica completa aqui
        pass
        
    def iniciar_servidor(self):
        """Inicia servidor Flask"""
        app = Flask(__name__)
        
        @app.route('/webhook/whatsapp', methods=['POST'])
        def webhook():
            # Implementar webhook
            pass
            
        app.run(host='0.0.0.0', port=8080)

if __name__ == "__main__":
    agent = AgentIA()
    agent.iniciar_servidor()
```

---

## üîß CONFIGURA√á√ïES NECESS√ÅRIAS

### Vari√°veis de Ambiente
```bash
# .env
SUPABASE_URL=https://rqyyoofuwrwwfcuxfjwu.supabase.co
SUPABASE_KEY=eyJhbGciOiJIUzI1NiIsInR5cCI6IkpXVCJ9.eyJpc3MiOiJzdXBhYmFzZSIsInJlZiI6InJxeXlvb2Z1d3J3d2ZjdXhmand1Iiwicm9sZSI6ImFub24iLCJpYXQiOjE3NTAwODk2MjUsImV4cCI6MjA2NTY2NTYyNX0.lBOrYvRIGEhLLMgcaaooS9-w2M8VAZW_4rQYFxc6abE
WHATSAPP_API_TOKEN=seu_token_whatsapp
OPENAI_API_KEY=sua_chave_openai
```

### Instala√ß√£o no Servidor VPS
```bash
# Instalar depend√™ncias do sistema
sudo apt update
sudo apt install python3 python3-pip nginx

# Clonar projeto
git clone [seu-repositorio]
cd ai_agent_vps

# Criar ambiente virtual
python3 -m venv venv
source venv/bin/activate

# Instalar depend√™ncias Python
pip install -r requirements.txt

# Configurar vari√°veis de ambiente
cp .env.example .env
nano .env  # Editar com suas credenciais

# Executar aplica√ß√£o
python main.py
```

---

## üìä MONITORAMENTO E LOGS

### Logs Importantes para Implementar
```python
import logging

# Configurar logging
logging.basicConfig(
    level=logging.INFO,
    format='%(asctime)s - %(name)s - %(levelname)s - %(message)s',
    handlers=[
        logging.FileHandler('ai_agent.log'),
        logging.StreamHandler()
    ]
)

logger = logging.getLogger(__name__)

# Exemplos de logs
logger.info(f"ü§ñ Nova negocia√ß√£o iniciada: {negotiation_id}")
logger.info(f"üìÑ Documento recebido: {document_type}")
logger.error(f"‚ùå Erro ao processar mensagem: {error}")
logger.warning(f"‚ö†Ô∏è Documento rejeitado: {rejection_reason}")
```

### M√©tricas para Acompanhar
```python
def obter_metricas_diarias():
    """
    Gera m√©tricas di√°rias do agente IA
    """
    from datetime import datetime, timedelta
    
    hoje = datetime.now().date()
    ontem = hoje - timedelta(days=1)
    
    # Negocia√ß√µes iniciadas hoje
    negociacoes_hoje = supabase.table('ai_negotiations').select('*').gte(
        'created_at', f'{hoje}T00:00:00'
    ).execute()
    
    # Documentos processados hoje
    documentos_hoje = supabase.table('ai_documents').select('*').gte(
        'uploaded_at', f'{hoje}T00:00:00'
    ).execute()
    
    # Conversas hoje
    conversas_hoje = supabase.table('ai_conversations').select('*').gte(
        'timestamp', f'{hoje}T00:00:00'
    ).execute()
    
    return {
        'negociacoes_iniciadas': len(negociacoes_hoje.data),
        'documentos_processados': len(documentos_hoje.data),
        'mensagens_trocadas': len(conversas_hoje.data),
        'data': hoje.isoformat()
    }
```

---

## üéØ PONTOS IMPORTANTES PARA O DESENVOLVEDOR

### 1. Seguran√ßa
- **NUNCA** exponha as chaves da API diretamente no c√≥digo
- Use vari√°veis de ambiente para credenciais
- Valide todas as entradas do usu√°rio
- Implemente rate limiting para evitar spam

### 2. Performance
- Use connection pooling para o banco de dados
- Implemente cache para consultas frequentes
- Processe documentos de forma ass√≠ncrona
- Monitore o uso de recursos da VPS

### 3. Escalabilidade
- Prepare para m√∫ltiplas conversas simult√¢neas
- Use filas para processar documentos
- Implemente logs estruturados
- Monitore m√©tricas de performance

### 4. Backup e Recupera√ß√£o
- Fa√ßa backup regular dos logs
- Monitore falhas de conex√£o com Supabase
- Implemente retry autom√°tico para opera√ß√µes cr√≠ticas
- Tenha um plano de recupera√ß√£o de desastres

---

## üìû SUPORTE E CONTATOS

### Recursos de Desenvolvimento
- **Supabase Dashboard**: https://supabase.com/dashboard/project/rqyyoofuwrwwfcuxfjwu
- **Documenta√ß√£o Supabase Python**: https://supabase.com/docs/reference/python
- **API Reference**: https://supabase.com/docs/guides/api

### Comandos √öteis para Debug
```bash
# Verificar logs em tempo real
tail -f ai_agent.log

# Testar conex√£o com Supabase
python -c "from models.supabase_client import SupabaseClient; client = SupabaseClient(); print('Conex√£o OK' if client.test_connection() else 'Erro na conex√£o')"

# Verificar status do servidor
curl -X GET http://localhost:8080/health

# Monitorar recursos do sistema
htop
```

---

## üöÄ PR√ìXIMOS PASSOS

### Desenvolvimento Fase 1 (B√°sico)
- [ ] Configurar ambiente Python na VPS
- [ ] Implementar conex√£o com Supabase
- [ ] Criar webhook WhatsApp b√°sico
- [ ] Implementar CRUD das negocia√ß√µes
- [ ] Testes b√°sicos de integra√ß√£o

### Desenvolvimento Fase 2 (IA)
- [ ] Integrar OpenAI para processamento de linguagem natural
- [ ] Implementar classifica√ß√£o de inten√ß√µes
- [ ] Criar fluxo de coleta de documentos
- [ ] Implementar valida√ß√£o autom√°tica de documentos
- [ ] Sistema de notifica√ß√µes para corretores



---

**üìù √öLTIMA ATUALIZA√á√ÉO**: Juno 2025  
**üîÑ VERS√ÉO**: 1.0  
**üë§ DESENVOLVEDOR**: [Vinicius) 

---

> **‚ö†Ô∏è IMPORTANTE**: Este documento deve ser atualizado sempre que houver mudan√ßas na estrutura do banco de dados ou nos fluxos de negocia√ß√£o. Mantenha sempre sincronizado com o c√≥digo em produ√ß√£o.

**üìß D√öVIDAS?** Entre em contato com a equipe de desenvolvimento do sistema principal.
